# Принципи SOLID — Liskov Substitution Principle (LSP)

## Вступ

Принцип підстановки Лісков (LSP) стверджує, що об'єкти в програмі повинні бути замінюваними на екземпляри їхніх підтипів без зміни правильності виконання програми. Простими словами: клас-спадкоємець не повинен ламати поведінку, яку очікує код від базового класу.

Нижче наведено два приклади порушення цього принципу та способи їх виправлення.


## Приклад 1. Птах і Пінгвін (Проблема "Не всі птахи літають")

Це класичний приклад. Є базовий клас `Bird`, який має метод `Fly()`. Створюємо клас `Penguin`, який успадковується від птаха.

### Порушення LSP

Проблема в тому, що пінгвіни не вміють літати. Коли викликається метод `Fly()` у пінгвіна, доводиться або нічого не робити, або повідомляти про помилку.

```csharp
public class Bird
{
    public virtual void Fly()
    {
        Console.WriteLine("Я лечу!");
    }
}

public class Penguin : Bird
{
    public override void Fly()
    {
        // Помилка: Пінгвін не може літати!
        // Це порушує очікування програми, яка думає, що всі Bird вміють літати.
        throw new Exception("Пінгвіни не літають!");
    }
}

```

**В чому проблкма?:** Якщо є список птахів `List<Bird>`, і потрібно запустити їх усіх у небо, програма "впаде", коли дійде черга до пінгвіна.

### Рефакторинг

Потрібно розділити можливості. Не всі птахи літають, тому метод `Fly` не повинен бути у базовому класі `Bird`.

```csharp
// Базовий клас для всіх птахів з спільними рисами
public class Bird 
{ 
    public void Eat() { ... }
}

// Інтерфейс тільки для тих, хто літає
public interface IFlyingBird
{
    void Fly();
}

// Голуб — це птах, що літає
public class Pigeon : Bird, IFlyingBird
{
    public void Fly() { Console.WriteLine("Я лечу!"); }
}

// Пінгвін — це просто птах
public class Penguin : Bird
{
    // Методу Fly тут просто немає, і помилки теж немає
}

```


## Приклад 2. Автомобіль і Електрокар (Проблема "Заправки паливом")

Припустимо, що є базовий клас `Car`, який має метод `FillGas()`. Створюємо клас `Tesla`, який успадковується від `Car`.

### Порушення LSP

Tesla — це машина, але вона не має бензобака. Реалізація методу FillGas() для неї неможлива або безглузда.

```csharp
public class Car
{
    public virtual void FillGas()
    {
        Console.WriteLine("Бак заправлено бензином.");
    }
}

public class Tesla : Car
{
    public override void FillGas()
    {
        // Помилка: Куди лити бензин? Це електрокар!
        throw new NotImplementedException(); 
    }
}

```

**В чому проблема?:** Код на заправці, який очікує будь-яку `Car`, спробує залити бензин у Теслу і отримає помилку. Тож програма передбачає собою знання клієнта щодо деталі реалізації ("Якщо це Тесла, то не заправляй").

### Рефакторинг

Потрібно змінити абстракцію. Замість конкретного "Заправити бензином", зробимо більш загальний метод "Поповнити енергію" або розділимо класи.

```csharp
// Базовий клас
public abstract class Vehicle 
{
    public abstract void Refuel(); // Абстрактне "Поповнити запас ходу"
}

public class PetrolCar : Vehicle
{
    public override void Refuel() 
    {
        Console.WriteLine("Заливаємо бензин...");
    }
}

public class ElectricCar : Vehicle
{
    public override void Refuel()
    {
        Console.WriteLine("Заряджаємо батарею...");
    }
}

```

Тепер код може викликати `Refuel()` для будь-якого транспорту, і це буде коректно працювати і для бензинового авто, і для електрокара.

## Висновок

Порушення LSP призводить до ненадійного коду, де нам доводиться постійно робити перевірки типу ("А чи не є цей об'єкт пінгвіном?"). Дотримання цього принципу дозволяє писати код, який впевнено працює з будь-якими спадкоємцями, не знаючи їхніх конкретних особливостей.
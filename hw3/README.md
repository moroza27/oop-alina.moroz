
# Тема: ISP та DIP

## Вступ
Принципи **ISP** (Interface Segregation Principle) та **DIP** (Dependency Inversion Principle) є ключовими для побудови гнучкої архітектури. Вони допомагають зменшити зв'язність коду (coupling) та спростити його тестування. У цій доповіді розглядається суть цих принципів, приклади їх порушення та виправлення, а також їхній взаємозв'язок.


## 1. Interface Segregation Principle (ISP) — Принцип розділення інтерфейсу

**Суть:** Клієнти не повинні залежати від методів, які вони не використовують. Краще мати багато вузькоспеціалізованих інтерфейсів, ніж один загальний ("God Interface").

### Приклад порушення ISP
Уявімо інтерфейс для багатофункціонального пристрою (БФП).

```csharp
// Порушення: Один "жирний" інтерфейс
public interface IMachine
{
    void Print(Document d);
    void Scan(Document d);
    void Fax(Document d);
}

// Проблема: Простий принтер змушений реалізовувати методи, які йому не потрібні
public class SimplePrinter : IMachine
{
    public void Print(Document d) 
    { 
        // Логіка друку 
    }

    public void Scan(Document d) 
    { 
        throw new NotImplementedException(); // Принтер не вміє сканувати
    }

    public void Fax(Document d) 
    { 
        throw new NotImplementedException(); // Принтер не вміє надсилати факс
    }
}

```

### Вирішення проблеми (Refactoring)

Розділимо великий інтерфейс на менші, спеціалізовані частини.

```csharp
// Правильно: Розділені інтерфейси
public interface IPrinter { void Print(Document d); }
public interface IScanner { void Scan(Document d); }
public interface IFax { void Fax(Document d); }

// Тепер SimplePrinter реалізує тільки те, що йому потрібно
public class SimplePrinter : IPrinter
{
    public void Print(Document d) { /* Друк */ }
}

// А просунута машина може реалізувати все
public class XeroxMachine : IPrinter, IScanner, IFax
{
    public void Print(Document d) { /* ... */ }
    public void Scan(Document d) { /* ... */ }
    public void Fax(Document d) { /* ... */ }
}

```


## 2. Dependency Inversion Principle (DIP) — Принцип інверсії залежностей

**Суть:** Модулі високого рівня не повинні залежати від модулів низького рівня. Обидва повинні залежати від абстракцій. Абстракції не повинні залежати від деталей.

### Переваги застосування DIP (через Dependency Injection)

Застосування DIP, зазвичай через механізм **Dependency Injection (DI)**, дає такі переваги:

1. **Слабке зв'язування (Decoupling):** Класи не знають про конкретні реалізації інших класів, лише про їхні інтерфейси. Це дозволяє змінювати одну частину системи, не ламаючи іншу.
2. **Легкість заміни реалізацій:** Ми можемо легко замінити `SqlDatabase` на `FileDatabase` або `CloudDatabase`, не змінюючи жодного рядка коду в бізнес-логіці, якщо всі вони реалізують `IDatabase`.
3. **Паралельна розробка:** Поки один розробник пише бекенд (реалізацію), інший може писати фронтенд або логіку, використовуючи лише інтерфейс (контракт).

---

## 3. Взаємозв'язок: Як "вузькі" інтерфейси (ISP) сприяють кращому DI та тестуванню

Принципи ISP та DIP працюють у синергії. Ось чому дотримання ISP критично важливе для якісного Dependency Injection:

### Покращення Dependency Injection

Коли ми впроваджуємо залежності через конструктор, ми хочемо бути впевнені, що клас отримує лише те, що йому справді потрібно.

* **Без ISP:** Якщо ми передаємо "жирний" інтерфейс (наприклад, `IMachine` у клас, який лише друкує), ми створюємо ілюзію, що цей клас може також сканувати або відправляти факс. Це заплутує розробника і підвищує ризик помилок.
* **З ISP:** Ми передаємо конкретний `IPrinter`. Це робить код **самодокументованим**: з конструктора одразу видно, що цей клас буде лише друкувати.

### Покращення Unit-тестування

Це, мабуть, найбільша перевага.

* **Mocking (Створення імітацій):** Під час написання юніт-тестів нам часто потрібно створювати Mock-об'єкти для залежностей.
* Якщо інтерфейс величезний (порушує ISP), нам доведеться налаштовувати або реалізовувати заглушки для десятків методів, навіть якщо тестований метод використовує лише один з них.
* Якщо інтерфейс "вузький" (дотримується ISP), ми мокаємо лише один-два методи. Це робить тести **коротшими, чистішими та стійкішими до змін**.

### Висновок

Дотримання ISP робить наші абстракції точними, а дотримання DIP дозволяє будувати систему на основі цих абстракцій. Разом вони забезпечують архітектуру, яку легко підтримувати, розширювати та тестувати.